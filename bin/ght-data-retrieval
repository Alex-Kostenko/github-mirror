require 'rubygems'
require 'amqp'
require 'json'
require 'ghtorrent'
require 'pp'

class GHTDataRetrieval < GHTorrent::Command

  include GHTorrent::Settings

  attr_reader :settings, :name

  def parse(msg)
    JSON.parse(msg)
  end

  def PushEvent(evt)
    data = parse evt
    data['payload']['commits'].each do |c|
      url = c['url'].split(/\//)
      @gh.get_commit url[4], url[5], url[7]
    end
  end

  def WatchEvent(evt)
    data = parse evt
    user = data['actor']['login']
    #@gh.get_watched user, evt
  end

  def FollowEvent(evt)
    data = parse evt
    user = data['actor']['login']
    #@gh.get_followed user

    followed = data['payload']['target']['login']
    #@gh.get_followers followed
  end

  def handlers
    %w(PushEvent WatchEvent FollowEvent)
  end

  def prepare_options(options)
      @name = "ght-data-retrieval"
  end

  def go
    @gh = GHTorrent::Mirror.new(options[:config])
    @settings = @gh.settings

    # Graceful exit
    Signal.trap('INT') {
      info ("Received SIGINT, exiting")
      AMQP.stop { EM.stop }
    }
    Signal.trap('TERM') {
      info ("Received SIGTERM, exiting")
      AMQP.stop { EM.stop }
    }

    AMQP.start(:host => config(:amqp_host),
               :port => config(:amqp_port),
               :username => config(:amqp_username),
               :password => config(:amqp_password)) do |connection|

      channel = AMQP::Channel.new(connection, :prefetch => 5)
      exchange = channel.topic(config(:amqp_exchange), :durable => true,
                               :auto_delete => false)

      handlers.each { |h|
        queue = channel.queue("#{h}s", {:durable => true})\
                       .bind(exchange, :routing_key => "evt.#{h}")

        puts "Binding handler #{h} to routing key evt.#{h}"

        queue.subscribe(:ack => true) do |headers, msg|
          begin
            send(h, msg)
            headers.ack
          rescue Exception => e
            # Give a message a chance to be reprocessed
            if headers.redelivered?
              headers.reject(:requeue => false)
            else
              headers.reject(:requeue => true)
            end

            #pp JSON.parse(msg)
            STDERR.puts e
            STDERR.puts e.backtrace.join("\n")
          end
        end
      }
    end
  end
end

GHTDataRetrieval.run
