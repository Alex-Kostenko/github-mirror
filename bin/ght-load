#!/usr/bin/env ruby
#
# Loads items from Mongo to the queue for further processing
#
#
# Copyright 2012 Georgios Gousios <gousiosg@gmail.com>
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following
# conditions are met:
#
#   1. Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer.
#
#   2. Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

require 'rubygems'
require 'ghtorrent-old'
require 'mongo'
require 'amqp'
require 'set'
require 'eventmachine'
require 'optparse'
require 'ostruct'
require 'pp'
require "amqp/extensions/rabbitmq"

class GHTLoad < GHTorrent::Command

  def col_info()
    {
        :commits => {
            :name => "commits",
            :payload => "commit.id",
            :unq => "commit.id",
            :col => GH.commits_col,
            :routekey => "commit.%s"
        },
        :events => {
            :name => "events",
            :payload => "",
            :unq => "type",
            :col => GH.events_col,
            :routekey => "evt.%s"
        }
    }
  end

  def prepare_options(options)
    options.banner <<-BANNER
Loads object ids from a collection to a queue for further processing.

#{command_name} [options] collection

#{command_name} options:
    BANNER

    options.opt :earliest, 'Seconds since epoch of earliest item to load',
      :short => 'e', :default => 0, :type => :int
    options.opt :filter,
                'Filter items by regexp on item attributes: item.attr=regexp',
                :short => 'f', :type => String, :multi => true
  end

  def validate
    super
    Trollop::die "no collection specified" unless args[0] && !args[0].empty?
    filter = options[:filter]
    case
      when filter.is_a?(Array)
        options[:filter].each { |x|
          Trollop::die "not a valid filter #{x}" unless is_filter_valid?(x)
        }
      when filter == []
        # Noop
      else
        Trollop::die "A filter can only be a string"
    end
  end

  def go
    @gh = GHTorrent::Mirror.new(options[:config])
    @settings = @gh.settings

    GH.init(options[:config])
    # Message tags await publisher ack
    awaiting_ack = SortedSet.new

    # Num events read
    num_read = 0

    collection = case args[0]
                   when "events"
                     :events
                   when "commits"
                     :commits
                 end

    puts "Loading from collection #{collection}"
    puts "Loading items after #{Time.at(options[:earliest])}" if options[:verbose]

    what = case
             when options[:filter].is_a?(Array)
               options[:filter].reduce({}) { |acc,x|
                 (k,r) = x.split(/=/)
                 acc[k] = Regexp.new(r)
                 acc
               }
             when filter == []
               {}
           end

    from = {'_id' => {'$gte' => BSON::ObjectId.from_time(Time.at(options[:earliest]))}}

    (puts "Mongo filter:"; pp what.merge(from)) if options[:verbose]

    AMQP.start(:host => GH.settings['amqp']['host'],
               :port => GH.settings['amqp']['port'],
               :username => GH.settings['amqp']['username'],
               :password => GH.settings['amqp']['password']) do |connection|

      channel = AMQP::Channel.new(connection)
      exchange = channel.topic(GH.settings['amqp']['exchange'],
                               :durable => true, :auto_delete => false)

      # What to do when the user hits Ctrl+c
      show_stopper = Proc.new {
        connection.close { EventMachine.stop }
      }

      # Read next 1000 items and queue them
      read_and_publish = Proc.new {

        read = 0
        col_info[collection][:col].find(what.merge(from),
                                       :skip => num_read,
                                       :limit => 1000).each do |e|

          payload = GH.read_value(e, col_info[collection][:payload])
          payload = if payload.class == BSON::OrderedHash
                      payload.delete "_id" # Inserted by MongoDB on event insert
                      payload.to_json
                    end
          read += 1
          unq = GH.read_value(e, col_info[collection][:unq])
          if unq.class != String or unq.nil? then
            throw Exception("Unique value can only be a String")
          end

          key = col_info[collection][:routekey] % unq

          exchange.publish payload, :persistent => true, :routing_key => key

          num_read += 1
          puts("Publish id = #{unq} (#{num_read} total)") if options.verbose
          awaiting_ack << num_read
        end

        # Nothing new in the DB and no msgs waiting ack
        if read == 0 and awaiting_ack.size == 0
          puts("Finished reading, exiting")
          show_stopper.call
        end
      }

      # Remove acknowledged or failed msg tags from the queue
      # Trigger more messages to be read when ack msg queue size drops to zero
      publisher_event = Proc.new { |ack|
        if ack.multiple then
          awaiting_ack.delete_if { |x| x <= ack.delivery_tag }
        else
          awaiting_ack.delete ack.delivery_tag
        end

        if awaiting_ack.size == 0
          puts("ACKS.size= #{awaiting_ack.size}") if options.verbose
          EventMachine.next_tick do
            read_and_publish.call
          end
        end
      }

      # Await publisher confirms
      channel.confirm_select

      # Callback when confirms have arrived
      channel.on_ack do |ack|
        puts "ACK: tag=#{ack.delivery_tag}, mul=#{ack.multiple}" if options.verbose
        publisher_event.call(ack)
      end

      # Callback when confirms failed.
      channel.on_nack do |nack|
        puts "NACK: tag=#{nack.delivery_tag}, mul=#{nack.multiple}" if options.verbose
        publisher_event.call(nack)
      end

      # Signal handlers
      Signal.trap('INT', show_stopper)
      Signal.trap('TERM', show_stopper)

      # Trigger start processing
      EventMachine.add_timer(0.1) do
        read_and_publish.call
      end
    end
  end

  private

  def is_filter_valid?(filter)
    (k, r) = filter.split(/=/)
    return false if r.nil?
    begin
      Regexp.new(r)
      true
    rescue
      false
    end
  end
end

GHTLoad.run

#vim: set filetype=ruby expandtab tabstop=2 shiftwidth=2 autoindent smartindent:
